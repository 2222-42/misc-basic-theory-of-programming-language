# 1 プログラミング言語のモデル

- 実行可能な計算の記述言語
- ソフトウェアの論理構造の記述システム

これら2つの側面を併せ持ったモデルの構築をやりたい。まずは計算のモデルについて。

## 1.1 計算モデルの必要性

von Nwuman型だと高水準言語ほど豊かではない。だから、数学的なもしくは論理学的な記述が可能な計算モデルが欲しい。けど、数学や論理学の諸概念は、プログラムとしては実行不可能なものがあり、そのままでは使えない。

以下の2条件を満たす計算のモデルが欲しい:

- 抽象的な記述が可能で、
- 実際に実行可能な

。関数型を扱うが、関数型と論理型のそれぞれの特徴。

|関数型|論理型|
|--|--|
|計算可能な関数|自動証明可能な論理式|
|関数の値を求める|証明を導出する|
|関数の定義を構築|定理や推論規則の定義を構築|

- 型なしラムダ計算はプログラムの表現する計算そのもののモデル
- 型付ラムダ計算は
  - 型なしラムダ計算に
  - プログラミングにとって有用な種々の構造を「型」として導入したシステム
    - 型は型システムで要素間の関係の規定を調べられる

型付λ計算は数学的モデルと考えられる。

## 1.2 

関係rについて

- `r+`: 推移的閉包
  - `r`を含み、推移的である、最小の関係
- `r*`: 反射w的推移的閉包
  - `r`を含み、推移的かつ反射的である、最小の関係

関数について

- `f|X`: `f`の`X`への制限
- `f|\bar{x}`: `f|dom(f)\{x}`
- `f'= f{x:v}`
  - `dom(f') = dom(f)∪{x}`
  - `f'(y) = case y of x => v | _ => f(y)`


## 1.3

- 言語の帰納的な定義(inductive)
- 関数の再帰的な定義(recursive)

### 1.3.1

BNF記法:
- メタ変数: 定義しようとする言語の要素を代表する
- 言語の要素を生成する規則をメタ変数を含んだ文法として定義する
  - 規則は集合`L(E)`の性質を記述していると考えられる。

e.g.) `E ::= X1 | ... | Xn`

```
given U.
F = {F | f: U^n -> U}
```

nをfのランクと呼び、`n = rank(f)`と書く。

`f^{r(n)}` : ランクがnであるFの要素


定義:
```
set X ⊆U. 
f^r(n) (X) = {f^{r(n)} (x1, ..., xn) | (xi ∈ X)} 
F(x) = {f^{r(n)} (x1,...,xn) | (xi ∈ X, f^{r(n)} ∈ F)}
```

`F(X) ⊆ X`の時、Xは関数集合Fに関して閉じているという。
