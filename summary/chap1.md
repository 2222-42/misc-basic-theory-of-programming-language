# 1 プログラミング言語のモデル

- 実行可能な計算の記述言語
- ソフトウェアの論理構造の記述システム

これら2つの側面を併せ持ったモデルの構築をやりたい。まずは計算のモデルについて。

## 1.1 計算モデルの必要性

von Nwuman型だと高水準言語ほど豊かではない。だから、数学的なもしくは論理学的な記述が可能な計算モデルが欲しい。けど、数学や論理学の諸概念は、プログラムとしては実行不可能なものがあり、そのままでは使えない。

以下の2条件を満たす計算のモデルが欲しい:

- 抽象的な記述が可能で、
- 実際に実行可能な

。関数型を扱うが、関数型と論理型のそれぞれの特徴。

|関数型|論理型|
|--|--|
|計算可能な関数|自動証明可能な論理式|
|関数の値を求める|証明を導出する|
|関数の定義を構築|定理や推論規則の定義を構築|

- 型なしラムダ計算はプログラムの表現する計算そのもののモデル
- 型付ラムダ計算は
  - 型なしラムダ計算に
  - プログラミングにとって有用な種々の構造を「型」として導入したシステム
    - 型は型システムで要素間の関係の規定を調べられる

型付λ計算は数学的モデルと考えられる。

## 1.2 本書で使用する集合に関する記法

関係rについて

- `r+`: 推移的閉包
  - `r`を含み、推移的である、最小の関係
- `r*`: 反射w的推移的閉包
  - `r`を含み、推移的かつ反射的である、最小の関係

関数について

- `f|X`: `f`の`X`への制限
- `f|\bar{x}`: `f|dom(f)\{x}`
- `f'= f{x:v}`
  - `dom(f') = dom(f)∪{x}`
  - `f'(y) = case y of x => v | _ => f(y)`


## 1.3　言語の文法構造の定義

- 言語の帰納的な定義(inductive)
- 関数の再帰的な定義(recursive)

### 1.3.1 形式言語の帰納的な定義

BNF記法:
- メタ変数: 定義しようとする言語の要素を代表する
- 言語の要素を生成する規則をメタ変数を含んだ文法として定義する
  - 規則は集合`L(E)`の性質を記述していると考えられる。

e.g.) `E ::= X1 | ... | Xn`

```
given U.
F = {F | f: U^n -> U}
```

nをfのランクと呼び、`n = rank(f)`と書く。

`f^{r(n)}` : ランクがnであるFの要素


定義:
```
set X ⊆U. 
f^r(n) (X) = {f^{r(n)} (x1, ..., xn) | (xi ∈ X)} 
F(x) = {f^{r(n)} (x1,...,xn) | (xi ∈ X, f^{r(n)} ∈ F)}
```

`F(X) ⊆ X`の時、Xは関数集合Fに関して閉じているという。

`C`は与えられた定数の集合であり、`C ⊆ U`である。

`C`の`F`に関する帰納的閉包(`Ind(C, F)`): 

- 集合`C`を含む
- 関数集合`F`に関して閉じている
- 最小の集合である

関数`F`に関して閉じていることは、`∩`によって保存される。

```
Ind(C, F) = ∩{V | V ⊆ U, C ⊆ V, F(V) ⊆ V}
```

`Ind(C,F)`は漸化式で具体的に生成される

- `X_0 = C`
- `X_{i+1} = F(X_i) ∪ X_i` (`0≦i`)

命題1.3.1 `Ind(C, F) = ∪_{0 ≦ i} X_i`

BNF文法で与えられる言語は、帰納的閉包として定義できる。BNF文法で定義される言語は以下のように定義できる:

```
L(E) = Ind({X_i | X_i はEを含まない}, {f_{X_il | X_iはEを含む}})
```

(帰納的閉包に対する帰納原理) 帰納的な証明が有効であることの根拠は、次の性質「`C`を含む`Ind(C,F)`の部分集合`Y`が`F`に関して閉じていれば、`Y = Ind(C,F)`である」に基づく。

## 1.3.2 言語に対する再帰的な関数定義と文法の曖昧さ

- `X`: `C`の`F`にあkんする帰納的閉包(`Ind(C,F)`)
- `A`: given set 

`φ: X -> A`に関する以下のような規則のことを、関数の再帰的な定義であるという

1. 定数集合`C`の任意の要素`c`に対し、`φ(c) = \bar{c}`
2. `F`の任意の要素`f^{r(n)}`に対して、関数`\bar{f^{r(n)}}: A^n -> A`を定め、`f^{r(n)} (x1, ..., xn)`に対応する値を以下の規則によって定める。`φ(f^{r(n)} (x1, ..., xn)) = \bar{f^{r(n)}} (x1, ..., xn)`

異なった文法規則の適用の結果が同一の文となりうるような文法があり、そのような文法は曖昧であるという。文法によっては、再帰的な規則のみでは関数が定義できない場合がある。

再帰的な関数定義は
- 集合の要素に対してではなく
- 集合の要素の生成系列に対するもの

再帰的な関数定義が意味を持つためには、生成系列の集合と一対一の関係にあるような言語(曖昧性のない文法で生成された言語)でなければならない

曖昧性のない言語の条件は、帰納的閉包`X = Ind(C,F)`に関する条件として、以下の通り

1. `F`の任意の`f^{r(n)}`, `g^{r(n)}`に対し、`f^{r(n)} != g^{r(n)}`ならば、`f^{r(n)}(X) ∩ g^{r(n)}(X) = ∅`
2. `F`の任意の`f^{r(n)}`に対し、`f^{r(n)}(X) ∩ C = ∅`
3. `F`の任意の`f^{r(n)}`に対し、`f^{r(n)} | X^n` は単射関数

この性質を満たすような帰納的に生成された集合は、自由に生成された集合と呼ぶ。

定理1.3.1 は、唯一の準同型拡張、つまり、自由に生成された集合に対しては、関数の再帰的な定義は、必ず唯一の関数を定義することを示している。

BNF文法で定義された任意の言語は、自由に生成された集合と捉えることができる。それは、
- 文法によって生成される文字列の集合ではなく、
- 文字列の生成に使われる文法規則の系列そのものと解釈することによる。
  - 文法規則の系列は、構文木、つまり生成構造を表す木で表される
    - プログラミング言語は構文木の集合と捉えることができる
- 定理1.3.1により、言語の文法に関する再帰的な規則は必ず唯一の関数を定義する事を保証されている

LR構文解析の原理、Knuthの命題、最右導出をたどることに相当する。

## 1.4 型無しラムダ計算

### 1.4.1

- `Var`: 可算無限個の変数の集合
- `x`: メタ変数で`Var`を代表する
- ラムダ式の集合 `M ::= x | (lambda x. M) | (M M)`
  - `(lambda x. M)`はラムダ抽象(lambda abstraction)
    - `M`内の`x`を束縛変数と呼ぶ
    - 束縛されていない変数を自由変数
  - `(M M)`はラムダ適用(lambda application)
    - 自由変数の捕捉が発生する場合があるので、α変換の必要がある
- α同値関係: `λx. M = λy. [y/x] M (y ∉ FV(M))`
- β簡約公理: `(λx. M) N ==> [N/x] M`
  - `M --> N`で1ステップで簡約されるといい、その簡約関係の反射的推移的閉包 `M -*-> N`
  - 正規形:　`M --> N`なる`N`が存在しない時の`M`のこと
  - `M⇓N`: `M -*-> N`かつ、`N`が正規形
    - 正規形はプログラムの最終結果とみなせる
    - この関係が、ラムダ計算におけるプログラムのおいこなう計算のモデルである。
  
命題1.4.1

定理1.4.1(合流性)

命題1.4.1は定理1.4.1の系。

### 1.4.2 汎用な計算モデルとしての型無しラムダ計算

- コード化: 情報を有限なシンボル列で表現すること
  - コード: 表現されたもの

Key: データ構造が表現するべきは「ふるまい」そのものを関数として表現すること

論理値、自然数、n個の要素の組、

再帰的関数定義について、`FN =(β) N`を満たすラムダ式が求める`N`。
NはFの不動点と呼ばれる。
不動点演算子は、与えられたラムダ式からその不動点を計算する演算するもの。
もし不動点演算子があり、それをラムダ式として定義できれば、任意の再帰的関数がラムダ式として定義可能である。
その存在の一例が、Turingの不動点演算子。

### 1.4.3 ラムダ計算に基づくプログラミング言語のモデル

ラムダ計算は記述システムとしては必ずしもふさわしくない。
なぜなら、ラムダ式のみでは、それが表現する機能は不明確である。
例えば、自然数の零と論理値の偽と2つの要素から2番めの要素を取り出す演算とは、すべてラムダ式としては等しい。

記述システムとしては以下の2つが欲しい

- 実行可能なコードの記述
- 表現する計算の意図する性質や構造の表現

意図する性質や構造のために、型付ラムダ計算がよい。

同一の性質を持つ値の集合の基底型を、関係計算系であるラムダ計算に、埋め込んだシステム、それがプログラミング言語の基本的なモデルである。
どのような性質を型として導入するかで表現力が変わる。
単純なのは基底型と後悔の関数を含んだもの。
